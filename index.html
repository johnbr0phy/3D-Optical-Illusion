<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>The Ultimate 3D Optical Illusion</title>
  <style>
    /* Make the canvas fill the window with a black background */
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OrbitControls for interactive camera movement -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.128.0/examples/js/controls/OrbitControls.js"></script>  <!-- Corrected path -->
  <script>
    (function(){
      // Create scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 10);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Enable smooth interactive controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Create custom shader material for our torus knot optical illusion
      const uniforms = {
        time: { value: 0.0 },
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
      };

      const vertexShader = `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      const fragmentShader = `
        uniform float time;
        uniform vec2 resolution; // Use resolution uniform
        varying vec2 vUv;

        void main(){
          // Center the UV coordinates, and scale them based on resolution
          vec2 pos = (vUv - 0.5) * 2.0;
          pos.x *= resolution.x / resolution.y; // Correct aspect ratio

          float r = length(pos);
          float angle = atan(pos.y, pos.x);

          // Create a swirling pattern that evolves over time
          float pattern = sin(10.0 * r - time * 2.0 + angle * 5.0);

          // Map the pattern to a dynamic color gradient
          vec3 color = mix(vec3(0.1, 0.0, 0.3), vec3(0.9, 0.7, 0.0), smoothstep(-1.0, 1.0, pattern));

          // Add a pulsing effect to further enhance the illusion
          color *= 0.5 + 0.5 * sin(time + r * 10.0);
          gl_FragColor = vec4(color, 1.0);
        }
      `;

      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.DoubleSide
      });

      // Create a torus knot geometry and apply our shader material
      const geometry = new THREE.TorusKnotGeometry(2, 0.5, 200, 32);
      const torusKnot = new THREE.Mesh(geometry, shaderMaterial);
      scene.add(torusKnot);

      // Create a dynamic particle field as a background to boost depth and parallax
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = 10000;
      const positions = new Float32Array(particlesCount * 3);

      for (let i = 0; i < particlesCount; i++){
        positions[i * 3]     = (Math.random() - 0.5) * 200;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.2,
        transparent: true,
        opacity: 0.5
      });

      const particleField = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particleField);

      // Update renderer and camera on window resize
      window.addEventListener('resize', onWindowResize, false);
      function onWindowResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
      }

      // Animation loop: update time, rotate the torus knot, and render the scene
      const clock = new THREE.Clock();
      function animate(){
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        uniforms.time.value += delta;

        // Slow, hypnotic rotation for the torus knot
        torusKnot.rotation.x += 0.01;
        torusKnot.rotation.y += 0.02;

        // Subtle rotation of the particle field enhances the parallax effect
        particleField.rotation.y += 0.001;

        controls.update();
        renderer.render(scene, camera);
      }

      animate();
    })();
  </script>
</body>
</html>
