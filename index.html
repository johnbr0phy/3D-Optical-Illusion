<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Ultimate Portal Optical Illusion</title>
  <style>
    /* Fullscreen canvas with a deep black background */
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Use a module script to import Three.js and OrbitControls -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

    // Create the renderer and append it to the document
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // =====================
    // Main Scene Setup
    // =====================
    const mainScene = new THREE.Scene();
    const mainCamera = new THREE.PerspectiveCamera(
      60, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    mainCamera.position.set(0, 0, 10);

    // Instantiate OrbitControls from the imported module
    const controls = new OrbitControls(mainCamera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    // =====================
    // Portal Scene Setup (Offscreen)
    // =====================
    const portalScene = new THREE.Scene();
    const portalCamera = new THREE.PerspectiveCamera(
      60, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    portalCamera.position.set(0, 0, 8);

    // Create an offscreen render target for multi-pass rendering
    const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

    // Create a torus knot in the portal scene with a custom, swirling shader
    const portalUniforms = {
      time: { value: 0.0 },
      resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
    };

    const portalVertexShader = `
      varying vec2 vUv;
      void main(){
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const portalFragmentShader = `
      uniform float time;
      varying vec2 vUv;
      void main(){
        // Center and scale UV coordinates
        vec2 uv = (vUv - 0.5) * 2.0;
        float r = length(uv);
        float a = atan(uv.y, uv.x);
        // Create an evolving swirling pattern
        float pattern = sin(10.0 * r - time * 3.0 + a * 5.0);
        vec3 color = mix(vec3(0.2, 0.0, 0.5), vec3(1.0, 0.8, 0.0), smoothstep(-1.0, 1.0, pattern));
        color *= 0.5 + 0.5 * sin(time + r * 10.0);
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    const portalMaterial = new THREE.ShaderMaterial({
      uniforms: portalUniforms,
      vertexShader: portalVertexShader,
      fragmentShader: portalFragmentShader,
      side: THREE.DoubleSide
    });

    const torusGeometry = new THREE.TorusKnotGeometry(2, 0.5, 200, 32);
    const torusKnot = new THREE.Mesh(torusGeometry, portalMaterial);
    portalScene.add(torusKnot);

    // =====================
    // Portal "Window" in the Main Scene
    // =====================
    // This plane will display the offscreen-rendered portal scene with an extra distortion effect.
    const portalPlaneUniforms = {
      time: { value: 0.0 },
      portalTexture: { value: renderTarget.texture },
      resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
    };

    const portalPlaneVertexShader = `
      varying vec2 vUv;
      void main(){
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const portalPlaneFragmentShader = `
      uniform float time;
      uniform sampler2D portalTexture;
      varying vec2 vUv;
      void main(){
        // Distort UV coordinates to create a fluid, portal-like effect
        vec2 uv = vUv;
        uv.x += 0.02 * sin(uv.y * 10.0 + time * 2.0);
        uv.y += 0.02 * cos(uv.x * 10.0 + time * 2.0);
        vec4 color = texture2D(portalTexture, uv);
        // Add a subtle ripple effect on the colors
        float ripple = sin(10.0 * length(uv - 0.5) - time * 3.0);
        color.rgb += 0.1 * ripple;
        gl_FragColor = color;
      }
    `;

    const portalPlaneMaterial = new THREE.ShaderMaterial({
      uniforms: portalPlaneUniforms,
      vertexShader: portalPlaneVertexShader,
      fragmentShader: portalPlaneFragmentShader,
      transparent: true
    });

    const planeGeometry = new THREE.PlaneGeometry(6, 4, 32, 32);
    const portalPlane = new THREE.Mesh(planeGeometry, portalPlaneMaterial);
    portalPlane.position.set(0, 0, 0);
    mainScene.add(portalPlane);

    // =====================
    // Particle Field Background for Extra Depth & Parallax
    // =====================
    const particlesCount = 5000;
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particlesCount * 3);
    for (let i = 0; i < particlesCount; i++){
      positions[i*3]     = (Math.random() - 0.5) * 200;
      positions[i*3 + 1] = (Math.random() - 0.5) * 200;
      positions[i*3 + 2] = (Math.random() - 0.5) * 200;
    }
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const particlesMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.5,
      transparent: true,
      opacity: 0.6
    });
    const particleField = new THREE.Points(particlesGeometry, particlesMaterial);
    mainScene.add(particleField);

    // =====================
    // Handle Window Resizing
    // =====================
    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize(){
      mainCamera.aspect = window.innerWidth / window.innerHeight;
      mainCamera.updateProjectionMatrix();
      portalCamera.aspect = window.innerWidth / window.innerHeight;
      portalCamera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      portalPlaneUniforms.resolution.value.set(window.innerWidth, window.innerHeight);
      portalUniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    }

    // =====================
    // Animation Loop
    // =====================
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();

      // Update time uniforms for both the portal scene and portal plane
      portalUniforms.time.value = elapsed;
      portalPlaneUniforms.time.value = elapsed;

      // Rotate the torus knot in the portal scene for a mesmerizing swirl
      torusKnot.rotation.x += 0.01;
      torusKnot.rotation.y += 0.015;

      // Optional: rotate the portal plane slightly to enhance the 3D feel
      portalPlane.rotation.y += 0.002;

      // Update the orbit controls (for smooth interactivity)
      controls.update();

      // Multi-Pass Rendering:
      // First, render the portal scene into the render target (offscreen)
      renderer.setRenderTarget(renderTarget);
      renderer.render(portalScene, portalCamera);
      renderer.setRenderTarget(null); // Return to default framebuffer

      // Then, render the main scene with the portal window and particle background
      renderer.render(mainScene, mainCamera);
    }
    animate();
  </script>
</body>
</html>
