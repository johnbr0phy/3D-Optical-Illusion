<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>The Ultimate 3D Optical Illusion</title>
  <style>
    /* Make the canvas fill the window with a black background */
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OrbitControls for interactive camera movement -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.128.0/examples/js/controls/OrbitControls.js"></script>  <!-- Corrected path -->
  <script>
    (function(){
      // Create scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 10);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Enable smooth interactive controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Create custom shader material for our torus knot optical illusion
      const uniforms = {
        time: { value: 0.0 },
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
      };

      const vertexShader = `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      const fragmentShader = `
        uniform float time;
        uniform vec2 resolution; // Use resolution uniform
        varying vec2 vUv;

        void main(){
          // Center the UV coordinates, and scale them based on resolution
          vec2 pos = (vUv - 0.5) * 2.0;
          pos.x *= resolution.x / resolution.y; // Correct aspect ratio

          float r = length(pos);
          float angle = atan(pos.y, pos.x);

          // Create a swirling pattern that evolves over time
          float pattern = sin(10.0 * r - time * 2.0 + angle * 5.0);

          // Map the pattern to a dynamic color gradient
          vec3 color = mix(vec3(0.1, 0.0, 0.3), vec3(0.9, 0.7, 0.0), smoothstep(-1.0, 1.0, pattern));

          // Add a pulsing effect to further enhance the illusion
          color *= 0.5 + 0.5 * sin(time + r * 10.0);
          gl_FragColor = vec4(color, 1.0);
        }
      `;

      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.DoubleSide
      });

      // Create a torus knot geometry and apply our shader material
      const geometry = new THREE.TorusKnotGeometry(2, 0.5, 200, 32);
      const torusKnot = new THREE.Mesh(geometry, shaderMaterial);
      scene.add(torusKnot);

      // Create a dynamic particle field as a background to boost depth and parallax
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = 10000;
      const positions = new Float32Array(particlesCount * 3);

      for (let i = 0; i < particlesCount; i++){
        positions[i * 3]     = (Math.random() - 0.5) * 200;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.2,
        transparent: true,
        opacity: 0.5
      });

      const particleField = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particleField);

      // Update renderer and camera on window resize
      window.addEventListener('resize', onWindowResize, false);
      function onWindowResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
      }

      // Animation loop: update time, rotate the torus knot, and render the scene
      const clock = new THREE.Clock();
      function animate(){
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        uniforms.time.value += delta;

        // Slow, hypnotic rotation for the torus knot
        torusKnot.rotation.x += 0.01;
        torusKnot.rotation.y += 0.02;

        // Subtle rotation of the particle field enhances the parallax effect
        particleField.rotation.y += 0.001;

        controls.update();
        renderer.render(scene, camera);
      }

      animate();
    })();
  </script>
</body>
</html>
content_copy
download
Use code with caution.
Html

Key changes and explanations:

Corrected OrbitControls Path:

The original code used a relative path (https://threejs.org/examples/js/controls/OrbitControls.js) that might work if you're serving the HTML from the threejs.org domain, but it's unreliable and incorrect for local development or deployment elsewhere.

I've changed it to use a CDN link, just like three.min.js, ensuring it will always load correctly:

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.128.0/examples/js/controls/OrbitControls.js"></script>
content_copy
download
Use code with caution.
Html

Important: The version numbers in the CDN links should match. I've used r128 for three.min.js and 0.128.0 for OrbitControls.js, which are compatible. Using mismatched versions can lead to errors. If you update Three.js, update OrbitControls too. The best way to guarantee this is to use the same major/minor version number (e.g. if Three.js is r150, use 0.150.x for OrbitControls, if available. You can find the correct matching versions on CDNs like cdnjs.com or unpkg.com)

Aspect Ratio Correction in Fragment Shader:

The original fragment shader didn't account for the aspect ratio of the window. This means the optical illusion would appear stretched if the window wasn't square.

I've added pos.x *= resolution.x / resolution.y; inside the fragmentShader:

vec2 pos = (vUv - 0.5) * 2.0;
pos.x *= resolution.x / resolution.y; // Correct aspect ratio
content_copy
download
Use code with caution.
Glsl

This line scales the x coordinate of the pos vector by the aspect ratio, ensuring the pattern is displayed correctly regardless of the window's dimensions. We also added uniform vec2 resolution to be able to access the resolution from the fragment shader.

Removed an unnecessary function call:

The code had a commented out line //window.onload = init();, but had wrapped the init code inside an immediately invoked function expression. The init function was not needed.

This revised code addresses the primary issues:

OrbitControls now loads correctly, allowing you to interact with the scene (rotate, zoom, pan).

The optical illusion is displayed correctly, without stretching, and the animation works smoothly.

The code is cleaner and more reliable.

This complete, corrected code should work out-of-the-box. Just save it as an HTML file (e.g., illusion.html) and open it in a web browser. You should see the animated torus knot with the particle background, and you'll be able to rotate the view using your mouse.
